---
title: "Utility Type များကို မိတ်ဆက်ခြင်း: သင့် Type များကို ပြောင်းလဲ ဖန်တီးပေးမယ့် ကိရိယာများ"
description: "Utility Type များကို မိတ်ဆက်ခြင်း: သင့် Type များကို ပြောင်းလဲ ဖန်တီးပေးမယ့် ကိရိယာများ"
---

(ဘာလို့ လိုအပ်တာလဲ): Type ပုံစံ ကွဲပြားမှုများ လိုအပ်လာခြင်း

"Module 1 မှာ ကျွန်တော်တို့ Code တွေကို Generic နဲ့ ဘယ်လို ပိုပြီး လိုက်လျောညီထွေ ဖြစ်အောင် ရေးရမလဲဆိုတာ လေ့လာခဲ့ပြီးပြီ။ အခု Type တွေ ကိုယ်တိုင်ကို ဘယ်လို ပြောင်းလဲ ဖန်တီးလို့ရလဲဆိုတာ ဆက်ပြောကြရအောင်။"

"တစ်ခါတလေမှာ ကျွန်တော်တို့က အခြေခံ Type (Base Type) လေးတစ်ခု (ဥပမာ interface User လိုမျိုး) သတ်မှတ်ထားတယ်။ ဒါပေမယ့် မတူညီတဲ့ အခြေအနေတွေအတွက် အဲဒီ Base Type ရဲ့ ပုံစံကို နည်းနည်းစီ ပြောင်းထားတဲ့ Type လေးတွေ လိုအပ်လာတတ်တယ်။"

User ရဲ့ Property တချို့ကိုပဲ လိုအပ်တဲ့ Update လုပ်တဲ့ Function အတွက် Type တစ်မျိုး။
User ရဲ့ Property အားလုံး ပါကို ပါရမယ့် ပြသရန် Component အတွက် Type တစ်မျိုး။
တစ်ခါ သတ်မှတ်ပြီးရင် ပြောင်းလို့မရတော့မယ့် Configuration object အတွက် Type တစ်မျိုး။
User ရဲ့ Property နည်းနည်းလေးပဲ လိုအပ်တဲ့ User preview card အတွက် Type တစ်မျိုး။
"ဒီ အခြေအနေ တစ်ခုချင်းစီအတွက် Interface အသစ် တစ်ခုစီ (ဥပမာ UserForUpdate, FullUser, ReadonlyUserConfig, UserPreview စသဖြင့်) သတ်မှတ်လို့ရပါတယ်။ ဒါပေမယ့် Interface များများအတွက် ဒီလိုမျိုး တစ်ခုချင်းစီ လိုက်လုပ်နေရရင် ဘယ်လောက် စကားလုံး ပိုများလဲ၊ မှားနိုင်ခြေ ဘယ်လောက် ရှိလဲ (Base User Interface မှာ တစ်ခုခု ပြောင်းသွားရင် အဲဒါနဲ့ သက်ဆိုင်တဲ့ Variation Type တွေ အကုန် လိုက်ပြင်ဖို့ မှတ်ထားရမယ်)၊ ပြီးတော့ Code က သိပ်ပြီး သပ်ရပ်လှပတော့မှာ မဟုတ်ဘူး။"

(ဘာလဲဆိုတော့): Utility Type တွေ ကယ်တင်ဖို့ ရောက်လာခြင်း!

"ဒီနေရာမှာပဲ Utility Types တွေက ဝင်လာတာပါ။ သူတို့ကို Type တွေအတွက် ကြိုပြီး တည်ဆောက်ထားတဲ့ ကူညီပေးမယ့် Function လေးတွေလို့ သဘောထားလို့ ရတယ်။ သူတို့က ရှိပြီးသား Type တစ်ခု (ဒါမှမဟုတ် Type တွေ) ကို Input အနေနဲ့ ယူပြီး ပြောင်းလဲထားတဲ့ Type အသစ်တစ်ခုကို Output အဖြစ် ထုတ်ပေးတယ်။"

"Utility Type အများစုဟာ သူ့ဘာသာသူ Generic Type တွေပဲ ဖြစ်တယ်။ ဆိုလိုတာက သူတို့က Module 1 မှာ လေ့လာခဲ့တဲ့ \<T> Syntax ကို သုံးပြီး ကျွန်တော်တို့ ထည့်ပေးတဲ့ Type တွေအပေါ် အလုပ်လုပ်ကြတာပေါ့။"

ဥပမာ နှိုင်းယှဉ်ချက်: "သစ်သားတုံး (ကိုယ့် Base Type) လေး တစ်တုံး ရှိတယ်လို့ စိတ်ကူးကြည့်ပါ။ Utility Types တွေက သင့် Workshop ထဲက Power Tool တွေနဲ့ တူတယ်။"

သစ်သားတုံးထဲက အပိုင်းလေးတွေ Pick (ရွေးယူ) ဒါမှမဟုတ် Omit (ချန်လှပ်) ဖို့ လွှ (Saw) လိုမျိုး။
သစ်သားတုံးရဲ့ အနားသပ်အားလုံးကို Partial (ချောမွေ့/ပါချင်မှပါ) ဖြစ်အောင် လုပ်ဖို့ စက္ကူပွတ်စက် (Sander) လိုမျိုး။
သစ်သားတုံးကို Readonly (ဖတ်လို့ပဲရမယ်၊ ပြင်မရဘူး) ဖြစ်အောင် လုပ်ဖို့ အရောင်တင်ဆီ (Varnish) လိုမျိုး။
(ကောင်းကျိုးများ): ဘာလို့ သုံးသင့်တာလဲ?

{`DRY (Don't Repeat Yourself - Code ကို မလိုအပ်ဘဲ ထပ်မရေးပါနှင့်): Base Type တစ်ခုကို တစ်ခါပဲ သတ်မှတ်ပြီး သူ့ကနေ လိုအပ်တဲ့ Variation Type တွေကို ဆက်ထုတ်ယူ (derive) နိုင်တယ်။
ထိန်းသိမ်းရလွယ်ခြင်း (Maintainability): Base Type မှာ ပြောင်းလဲမှုတွေ လုပ်တဲ့အခါ သူ့ကနေ ထုတ်ယူထားတဲ့ Type တွေဆီကို အဲဒီ ပြောင်းလဲမှုတွေက အလိုအလျောက် ရောက်ရှိသွားနိုင်တယ်။
ရှင်းလင်းပြတ်သားမှု (Expressiveness): Type ရဲ့ ရည်ရွယ်ချက်ကို ရှင်းရှင်းလင်းလင်း ပြောပြနိုင်တယ် (ဥပမာ Partial<User> လို့ မြင်တာနဲ့ "User ရဲ့ Property တချို့ပါတဲ့ Type" လို့ ချက်ချင်း သိစေတယ်)။
Type Safety (Type မှန်ကန်စိတ်ချရမှု): Type တွေကို ပြောင်းလဲ ဖန်တီးတာတွေဟာ Type Safety ဖြစ်စေတယ်။
တည်ဆောက်ပြီးသားဖြစ်ခြင်း (Built-in): သီးသန့် ဘာ Package မှ ထပ် Install လုပ်စရာ မလိုဘူး။ TypeScript မှာ ပါပြီးသား ကိရိယာတွေ ဖြစ်တယ်။
`}
