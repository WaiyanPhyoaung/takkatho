---
title: "MV* Architecture Patterns (MVC, MVVM, MVP) "
description: "MVC, MVVM, and MVP Patterns"
---

import { Code, Aside } from "@astrojs/starlight/components";

export const sliceExample = `
import { createSlice } from '@reduxjs/toolkit';

 const productsSlice = createSlice({
  name: 'products',
  initialState: [],
  reducers: {
    addProduct: (state, action) => {
      // Immer library ပါဝင်တဲ့အတွက် state ကို တိုက်ရိုက်ပြင်နိုင်
      state.push(action.payload);
    },
    removeProduct: (state, action) => {
      return state.filter(product => product.id !== action.payload.id);
    }
  }
});

// Action creators တွေကို အလိုအလျောက် generate လုပ်ပေးပြီးသား
export const { addProduct, removeProduct } = productsSlice.actions;

// Reducer ကို store မှာ သုံးဖို့ export လုပ်
export default productsSlice.reducer;
`

<Aside title="ရည်ရွယ်ချက်">
Application ကြီးလာရင် Data တွေ ဘယ်ကလာပြီး ဘယ်ကိုသွားမှန်း မသိတော့တဲ့ ပြဿနာ (State Management Hell) ကို ဖြေရှင်းဖို့ **Flux** နဲ့ **Redux** ပေါ်လာပါတယ်။
</Aside>

### Flux ဆိုတာ ဘာလဲ? (ဘဏ် ဥပမာ)
Flux ဆိုတာ Facebook က တီထွင်ခဲ့တဲ့ Pattern ပါ။ သူ့ရဲ့ အဓိက သဘောတရားက **"One Way Traffic"** (တစ်လမ်းသွား) ပါ။
ဘဏ်တစ်ခုကို မြင်ယောင်ကြည့်ပါ။

1.  **View (Customer):** ငွေထုတ်ချင်တယ်။ (Button နှိပ်)
2.  **Action (Withdrawal Slip):** "ငွေ ၁ သိန်း ထုတ်မည်" ဆိုတဲ့ စာရွက် (Slip) ဖြည့်ရတယ်။
3.  **Dispatcher (Bank Teller):** စာရွက်ကို လက်ခံပြီး စစ်ဆေးတယ်။
4.  **Store (Vault):** ငွေတိုက်ထဲက ပိုက်ဆံ လျော့သွားတယ်။ (State Update)
5.  **View (Balance Screen):** လက်ကျန်ငွေ ပြောင်းသွားတာကို မြင်ရတယ်။

Customer က ငွေတိုက်ထဲ ဝင်ပြီး ပိုက်ဆံ ယူပြေးလို့ မရပါဘူး (Direct State Mutation မရ)။ Slip ဖြည့်ပြီး Teller ကို ပေးမှ ရမှာပါ။ ဒါက Flux ရဲ့ အနှစ်သာရပါပဲ။

### Redux: The Modern Flux
Redux က Flux ကို ပိုကောင်းအောင် မွမ်းမံထားတာပါ။ အခုခေတ်မှာတော့ **Redux Toolkit (RTK)** ကို သုံးကြပါတယ်။

#### Redux Toolkit (RTK) နဲ့ ရေးပုံ
အရင်က Redux ရေးရတာ ရှုပ်ပေမယ့် RTK မှာ `createSlice` နဲ့ အရမ်း လွယ်သွားပါပြီ။

<Code code={sliceExample} lang="javascript" title="productSlice.js" />

### အဓိက ပါဝင်တဲ့ အရာများ
1.  **Store:** Application တစ်ခုလုံးရဲ့ Data တွေ သိမ်းထားတဲ့ "ဗဟိုဘဏ်"။
2.  **Slice:** Feature တစ်ခုချင်းစီအတွက် ခွဲထားတဲ့ "ဌာနခွဲ" (Product Slice, User Slice)။
3.  **Action:** "ဘာလုပ်မယ်" ဆိုတဲ့ အမိန့်စာ (`addProduct`, `removeProduct`)။
4.  **Reducer:** အမိန့်စာကို ဖတ်ပြီး Data ပြောင်းပေးတဲ့ "မန်နေဂျာ"။

> **မှတ်ချက်:** Redux Toolkit မှာ `state.push` လို့ ရေးလို့ ရတာက နောက်ကွယ်မှာ **Immer** ဆိုတဲ့ Library က ကူညီပေးနေလို့ပါ။ တကယ်တမ်း Redux က Immutable (မပြောင်းလဲနိုင်သော) ပါ။`

ဒီနည်းလမ်းက action တွေနဲ့ reducer တွေကို တစ်နေရာတည်းမှာပဲ စုစည်းထားတဲ့အတွက် ပိုပြီးရှင်းလင်းပြီး စီမံခန့်ခွဲရ လွယ်ကူစေပါတယ်။

### `productsSlice.actions` ဆိုတာ ဘာလဲ?
`createSlice` က `reducers` object ထဲမှာ သင်ရေးထားသည့် method တစ်ခုချင်းစီအတွက် **action creator function** ကို အလိုအလျောက် generate လုပ်ပေးပါတယ်။

ဥပမာ:
- သင် `reducers` ထဲမှာ `addProduct(state, action)` လို့ ရေးရင် ⇒ `productsSlice.actions.addProduct` ဆိုတဲ့ function တစ်ခု ရရှိလာမယ်
- `removeProduct` လည်း အတူတူပဲ ⇒ `productsSlice.actions.removeProduct`

ဒီ generated action creator တွေကို **destructure** လုပ်ပြီး export လုပ်ချင်လို့ သုံးထားတာက `export const { addProduct, removeProduct } = productsSlice.actions;` ဖြစ်ပါတယ်။

#### Action Creator က ဘာလုပ်ပေးတာလဲ?
`addProduct({ id: 1, name: 'Book' })` လို့ ခေါ်လိုက်သွားရင် Redux က အောက်ကလို action object တစ်ခုအဖြစ် အလိုအလျောက် ပြောင်းပေးတယ်:
```js
{ type: 'products/addProduct', payload: { id: 1, name: 'Book' } }
```
အဲဒီ `type` ကို သင်ကိုယ်တိုင် ရေးစရာမလိုတော့တဲ့ အတွက် Typo ပြဿနာ၊ duplication ပြဿနာတွေ လျော့နည်းစေတယ်။

#### ဘယ်နေရာမှာ သုံးလဲ?
UI component ထဲက event မှာ dispatch လုပ်ဖို့သုံးတယ်
```js
import { useDispatch } from 'react-redux';
import { addProduct } from './productSlice';

function AddButton() {
  const dispatch = useDispatch();
  return (
    <button onClick={() => dispatch(addProduct({ id: Date.now(), name: 'Pen' }))}>
      Add
    </button>
  );
}
```

### `productsSlice.reducer` ကို ဘာကြောင့် export default လုပ်ရတာလဲ?
Redux store တည်ဆောက်တဲ့အချိန်မှာ slice တစ်ခုချင်းစီရဲ့ reducer ကို store ကိုပေးရတယ်။ ဥပမာ -

```js
import { configureStore } from '@reduxjs/toolkit';
import productsReducer from './productSlice';

export const store = configureStore({
  reducer: {
    products: productsReducer
  }
});
```

### State ကို Component မှာ ဘယ်လို ဖတ်မလဲ?
```js
import { useSelector } from 'react-redux';

function ProductList() {
  const products = useSelector(state => state.products); // products slice state
  return (
    <ul>
      {products.map(p => <li key={p.id}>{p.name}</li>)}
    </ul>
  );
}
```

### Flow တစ်ခုလုံး Recap
1. User → Button နှိပ် = dispatch(addProduct(payload))
2. Redux → slice reducer ထဲက addProduct run
3. Immer → state ကို immutable နည်းလမ်းနဲ့ update
4. Store state အသစ် ပြင်ဆင်ပြီး
5. useSelector သုံးထားသော component တွေ re-render

### အကျဉ်းချုံး Key Points
- `productsSlice.actions` = action creator collection (type string တွေကို auto generate)
- `addProduct(payload)` ခေါ်တိုင်း `{ type: 'products/addProduct', payload }`
- `productsSlice.reducer` သည် slice state logic အားလုံးကို handle
- Store တွင် `{ products: productsSlice.reducer }` အနေနဲ့ တည်ဆောက်
- Component တွေက `useDispatch + useSelector` နဲ့ အသုံးပြု


