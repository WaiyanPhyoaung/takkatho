---
title: "Modern Frameworks & Monolith"
description: "Modern Frameworks & Monolith"
---

import { Aside } from "@astrojs/starlight/components";

<Aside title="ခေတ်သစ် Monolith">
Next.js, Remix, Angular တို့လို Modern Framework တွေက Monolith ကို အားပေးပါတယ်။ ဒါပေမဲ့ သူတို့သွားနေတာက **"Modular Monolith"** ပါ။
ဒါကို **"Modern Car (Tesla)"** နဲ့ နှိုင်းယှဉ်ကြည့်ရအောင်။
</Aside>

### Modern Frameworks = Modern Cars
Tesla ကားတစ်စီးဟာ အပြင်ကကြည့်ရင် တစ်စီးတည်း (One Unit) ပါ။ ဒါပေမဲ့ အတွင်းပိုင်းမှာ Battery Module, Motor Module, AI Module ဆိုပြီး သီးခြားစီ ဖွဲ့စည်းထားပါတယ်။

- **Next.js / Remix:**
  Page တွေ၊ Component တွေ ခွဲရေးထားပေမယ့်၊ နောက်ဆုံး Deploy လုပ်ရင် Server တစ်လုံးတည်း (သို့မဟုတ် Lambda Function တစ်စု) အနေနဲ့ တက်သွားပါတယ်။ ဒါဟာ **Monolith** ပါ။ ဒါပေမဲ့ အရမ်း စနစ်ကျတဲ့ Monolith ပါ။

- **Angular:**
  Module System (NgModules) နဲ့ Feature တွေကို သီးခြားစီ ခွဲထုတ်ထားပါတယ်။ ဒါပေမဲ့ နောက်ဆုံးမှာ `main.js` bundle တစ်ခုတည်း ထွက်လာပါတယ်။

### ဘယ်အချိန်မှာ Monolith မသုံးသင့်ဘူးလဲ? (Micro-Frontends သုံးသင့်ချိန်)
Tesla ကားတစ်စီး ဝယ်စီးတာက လူတိုင်းအတွက် အဆင်ပြေပါတယ်။ ဒါပေမဲ့ အောက်ပါ အခြေအနေတွေမှာတော့ မရတော့ပါဘူး။

1.  **Team Scale အရမ်းကြီးလာတဲ့အခါ:**
    Developer ၁၀၀ ကျော်လောက် ရှိလာပြီး၊ Team တစ်ခုချင်းစီက သီးခြား Feature တွေကို တာဝန်ယူရတဲ့အခါ (ဥပမာ - Checkout Team, Search Team, User Profile Team)။

2.  **Independent Deployment လိုအပ်တဲ့အခါ:**
    Checkout Team က သူတို့ Feature ကို ပြင်လိုက်ရင်၊ Search Team ရဲ့ Code ကို ပြန် Build/Deploy လုပ်စရာ မလိုချင်တဲ့အခါ။

3.  **Technology Diversity လိုချင်တဲ့အခါ:**
    Legacy Code တွေကို Angular နဲ့ ဆက်ထားပြီး၊ Feature အသစ်တွေကို React နဲ့ ရေးချင်တဲ့အခါမျိုး။

<Aside title="အနှစ်ချုပ်" type='tip'>
- **Monolith** ဆိုတာ Deployment Unit တစ်ခုတည်း ဖြစ်ခြင်းကို ဆိုလိုတာပါ။ Code တွေ ရှုပ်ပွနေတာကို ဆိုလိုတာ မဟုတ်ပါဘူး။
- **Micro-Frontend** ဆိုတာ Team တွေ၊ Deployment တွေကို ခွဲထုတ်ချင်မှသာ သုံးသင့်တဲ့ Advanced Pattern တစ်ခုပါ။ မလိုအပ်ဘဲ သုံးရင် ရှုပ်ထွေးမှု (Complexity) သာ တိုးလာပါလိမ့်မယ်။
</Aside>